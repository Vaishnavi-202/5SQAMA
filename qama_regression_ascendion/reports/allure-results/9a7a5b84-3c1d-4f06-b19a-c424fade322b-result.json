{"name": "test_help_about_details_flow", "status": "broken", "statusDetails": {"message": "pywinauto.findwindows.ElementNotFoundError: {'title_re': '.*HP Web Jetadmin.*', 'backend': 'uia', 'process': 14324}", "trace": "self = <pywinauto.application.WindowSpecification object at 0x000002A74CE16AC0>\ncriteria = [{'app': <pywinauto.application.Application object at 0x000002A74BAB2850>, 'backend': 'uia', 'title_re': '.*HP Web Jetadmin.*'}], timeout = 5.0\nretry_interval = 0.09\n\n    def __resolve_control(self, criteria, timeout=None, retry_interval=None):\n        \"\"\"\n        Find a control using criteria\n    \n        * **criteria** - a list that contains 1 or 2 dictionaries\n    \n             1st element is search criteria for the dialog\n    \n             2nd element is search criteria for a control of the dialog\n    \n        * **timeout** -  maximum length of time to try to find the controls (default 5)\n        * **retry_interval** - how long to wait between each retry (default .2)\n        \"\"\"\n        if timeout is None:\n            timeout = Timings.window_find_timeout\n        if retry_interval is None:\n            retry_interval = Timings.window_find_retry\n    \n        try:\n>           ctrl = wait_until_passes(\n                timeout,\n                retry_interval,\n                self.__get_ctrl,\n                (findwindows.ElementNotFoundError,\n                 findbestmatch.MatchError,\n                 controls.InvalidWindowHandle,\n                 controls.InvalidElement),\n                criteria)\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pywinauto\\application.py:250: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntimeout = 5.0, retry_interval = 0.09\nfunc = <bound method WindowSpecification.__get_ctrl of <pywinauto.application.WindowSpecification object at 0x000002A74CE16AC0>>\nexceptions = (<class 'pywinauto.findwindows.ElementNotFoundError'>, <class 'pywinauto.findbestmatch.MatchError'>, <class 'pywinauto.controls.hwndwrapper.InvalidWindowHandle'>, <class 'pywinauto.base_wrapper.InvalidElement'>)\nargs = ([{'app': <pywinauto.application.Application object at 0x000002A74BAB2850>, 'backend': 'uia', 'title_re': '.*HP Web Jetadmin.*'}],), kwargs = {}\nstart = 5846.0942149, time_left = -2.343674199999441, err = TimeoutError()\n\n    def wait_until_passes(timeout,\n                          retry_interval,\n                          func,\n                          exceptions=(Exception),\n                          *args, **kwargs):\n        \"\"\"\n        Wait until ``func(*args, **kwargs)`` does not raise one of the exceptions\n    \n        * **timeout**  how long the function will try the function\n        * **retry_interval**  how long to wait between retries\n        * **func** the function that will be executed\n        * **exceptions**  list of exceptions to test against (default: Exception)\n        * **args** optional arguments to be passed to func when called\n        * **kwargs** optional keyword arguments to be passed to func when called\n    \n        Returns the return value of the function\n        If the operation times out then the original exception raised is in\n        the 'original_exception' attribute of the raised exception.\n    \n        e.g. ::\n    \n            try:\n                # wait a maximum of 10.5 seconds for the\n                # window to be found in increments of .5 of a second.\n                # P.int a message and re-raise the original exception if never found.\n                wait_until_passes(10.5, .5, self.Exists, (ElementNotFoundError))\n            except TimeoutError as e:\n                print(\"timed out\")\n                raise e.\n        \"\"\"\n        start = timestamp()\n    \n        # keep trying until the timeout is passed\n        while True:\n            try:\n                # Call the function with any arguments\n                func_val = func(*args, **kwargs)\n    \n                # if no exception is raised then we are finished\n                break\n    \n            # An exception was raised - so wait and try again\n            except exceptions as e:\n    \n                # find out how much of the time is left\n                time_left = timeout - (timestamp() - start)\n    \n                # if we have to wait some more\n                if time_left > 0:\n                    # wait either the retry_interval or else the amount of\n                    # time until the timeout expires (whichever is less)\n                    time.sleep(min(retry_interval, time_left))\n    \n                else:\n                    # Raise a TimeoutError - and put the original exception\n                    # inside it\n                    err = TimeoutError()\n                    err.original_exception = e\n>                   raise err\nE                   pywinauto.timings.TimeoutError\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pywinauto\\timings.py:458: TimeoutError\n\nDuring handling of the above exception, another exception occurred:\n\ncls = <class '_pytest.runner.CallInfo'>, func = <function call_and_report.<locals>.<lambda> at 0x000002A74C2BF920>, when = 'call'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: Callable[[], TResult],\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,\n    ) -> CallInfo[TResult]:\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :type func: Callable[[], _pytest.runner.TResult]\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        instant = timing.Instant()\n        try:\n>           result: TResult | None = func()\n                                     ^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\_pytest\\runner.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>       lambda: runtest_hook(item=item, **kwds),\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        when=when,\n        reraise=get_reraise_exceptions(item.config),\n    )\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\_pytest\\runner.py:245: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HookCaller 'pytest_runtest_call'>, kwargs = {'item': <Function test_help_about_details_flow>}, firstresult = False\n\n    def __call__(self, **kwargs: object) -> Any:\n        \"\"\"Call the hook.\n    \n        Only accepts keyword arguments, which should match the hook\n        specification.\n    \n        Returns the result(s) of calling all registered plugins, see\n        :ref:`calling`.\n        \"\"\"\n        assert not self.is_historic(), (\n            \"Cannot directly call a historic hook - use call_historic instead.\"\n        )\n        self._verify_all_args_are_provided(kwargs)\n        firstresult = self.spec.opts.get(\"firstresult\", False) if self.spec else False\n        # Copy because plugins may register other plugins during iteration (#438).\n>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_hooks.py:512: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_pytest.config.PytestPluginManager object at 0x000002A747C16F90>, hook_name = 'pytest_runtest_call'\nmethods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\\\Users\\\\saraswat.gagan\\\\Ap...ule 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>, ...]\nkwargs = {'item': <Function test_help_about_details_flow>}, firstresult = False\n\n    def _hookexec(\n        self,\n        hook_name: str,\n        methods: Sequence[HookImpl],\n        kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        # called from all hookcaller instances.\n        # enable_tracing will set its own wrapping function at self._inner_hookexec\n>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_manager.py:120: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\\\Users\\\\saraswat.gagan\\\\Ap...ule 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>, ...]\ncaller_kwargs = {'item': <Function test_help_about_details_flow>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            if firstresult:  # first result hooks return a single value\n                result = results[0] if results else None\n            else:\n                result = results\n    \n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                try:\n                    if exception is not None:\n                        try:\n                            teardown.throw(exception)\n                        except RuntimeError as re:\n                            # StopIteration from generator causes RuntimeError\n                            # even for coroutine usage - see #544\n                            if (\n                                isinstance(exception, StopIteration)\n                                and re.__cause__ is exception\n                            ):\n                                teardown.close()\n                                continue\n                            else:\n                                raise\n                    else:\n                        teardown.send(result)\n                    # Following is unreachable for a well behaved hook wrapper.\n                    # Try to force finalizers otherwise postponed till GC action.\n                    # Note: close() may raise if generator handles GeneratorExit.\n                    teardown.close()\n                except StopIteration as si:\n                    result = si.value\n                    exception = None\n                    continue\n                except BaseException as e:\n                    exception = e\n                    continue\n                _raise_wrapfail(teardown, \"has second yield\")\n    \n        if exception is not None:\n>           raise exception\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:167: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\\\Users\\\\saraswat.gagan\\\\Ap...ule 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>, ...]\ncaller_kwargs = {'item': <Function test_help_about_details_flow>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            if firstresult:  # first result hooks return a single value\n                result = results[0] if results else None\n            else:\n                result = results\n    \n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                try:\n                    if exception is not None:\n                        try:\n>                           teardown.throw(exception)\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:139: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_pytest.logging.LoggingPlugin object at 0x000002A74CE041A0>, item = <Function test_help_about_details_flow>\n\n    @hookimpl(wrapper=True)\n    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:\n        self.log_cli_handler.set_when(\"call\")\n    \n        with self._runtest_for(item, \"call\"):\n>           yield\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\_pytest\\logging.py:850: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\\\Users\\\\saraswat.gagan\\\\Ap...ule 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>, ...]\ncaller_kwargs = {'item': <Function test_help_about_details_flow>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            if firstresult:  # first result hooks return a single value\n                result = results[0] if results else None\n            else:\n                result = results\n    \n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                try:\n                    if exception is not None:\n                        try:\n>                           teardown.throw(exception)\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:139: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_impl = <HookImpl plugin_name='allure_listener', plugin=<allure_pytest.listener.AllureListener object at 0x000002A74CBFAE40>>\nhook_name = 'pytest_runtest_call', args = [<Function test_help_about_details_flow>]\n\n    def run_old_style_hookwrapper(\n        hook_impl: HookImpl, hook_name: str, args: Sequence[object]\n    ) -> Teardown:\n        \"\"\"\n        backward compatibility wrapper to run a old style hookwrapper as a wrapper\n        \"\"\"\n    \n        teardown: Teardown = cast(Teardown, hook_impl.function(*args))\n        try:\n            next(teardown)\n        except StopIteration:\n            _raise_wrapfail(teardown, \"did not yield\")\n        try:\n            res = yield\n            result = Result(res, None)\n        except BaseException as exc:\n            result = Result(None, exc)\n        try:\n            teardown.send(result)\n        except StopIteration:\n            pass\n        except BaseException as e:\n            _warn_teardown_exception(hook_name, hook_impl, e)\n            raise\n        else:\n            _raise_wrapfail(teardown, \"has second yield\")\n        finally:\n            teardown.close()\n>       return result.get_result()\n               ^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:53: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pluggy._result.Result object at 0x000002A74CE546C0>\n\n    def get_result(self) -> ResultType:\n        \"\"\"Get the result(s) for this hook call.\n    \n        If the hook was marked as a ``firstresult`` only a single value\n        will be returned, otherwise a list of results.\n        \"\"\"\n        __tracebackhide__ = True\n        exc = self._exception\n        tb = self._traceback\n        if exc is None:\n            return cast(ResultType, self._result)\n        else:\n>           raise exc.with_traceback(tb)\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_result.py:103: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_impl = <HookImpl plugin_name='allure_listener', plugin=<allure_pytest.listener.AllureListener object at 0x000002A74CBFAE40>>\nhook_name = 'pytest_runtest_call', args = [<Function test_help_about_details_flow>]\n\n    def run_old_style_hookwrapper(\n        hook_impl: HookImpl, hook_name: str, args: Sequence[object]\n    ) -> Teardown:\n        \"\"\"\n        backward compatibility wrapper to run a old style hookwrapper as a wrapper\n        \"\"\"\n    \n        teardown: Teardown = cast(Teardown, hook_impl.function(*args))\n        try:\n            next(teardown)\n        except StopIteration:\n            _raise_wrapfail(teardown, \"did not yield\")\n        try:\n>           res = yield\n                  ^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\\\Users\\\\saraswat.gagan\\\\Ap...ule 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>, ...]\ncaller_kwargs = {'item': <Function test_help_about_details_flow>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            if firstresult:  # first result hooks return a single value\n                result = results[0] if results else None\n            else:\n                result = results\n    \n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                try:\n                    if exception is not None:\n                        try:\n>                           teardown.throw(exception)\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:139: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_impl = <HookImpl plugin_name='C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py', plugin=<module 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>\nhook_name = 'pytest_runtest_call', args = [<Function test_help_about_details_flow>]\n\n    def run_old_style_hookwrapper(\n        hook_impl: HookImpl, hook_name: str, args: Sequence[object]\n    ) -> Teardown:\n        \"\"\"\n        backward compatibility wrapper to run a old style hookwrapper as a wrapper\n        \"\"\"\n    \n        teardown: Teardown = cast(Teardown, hook_impl.function(*args))\n        try:\n            next(teardown)\n        except StopIteration:\n            _raise_wrapfail(teardown, \"did not yield\")\n        try:\n            res = yield\n            result = Result(res, None)\n        except BaseException as exc:\n            result = Result(None, exc)\n        try:\n            teardown.send(result)\n        except StopIteration:\n            pass\n        except BaseException as e:\n            _warn_teardown_exception(hook_name, hook_impl, e)\n            raise\n        else:\n            _raise_wrapfail(teardown, \"has second yield\")\n        finally:\n            teardown.close()\n>       return result.get_result()\n               ^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:53: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pluggy._result.Result object at 0x000002A74CE547C0>\n\n    def get_result(self) -> ResultType:\n        \"\"\"Get the result(s) for this hook call.\n    \n        If the hook was marked as a ``firstresult`` only a single value\n        will be returned, otherwise a list of results.\n        \"\"\"\n        __tracebackhide__ = True\n        exc = self._exception\n        tb = self._traceback\n        if exc is None:\n            return cast(ResultType, self._result)\n        else:\n>           raise exc.with_traceback(tb)\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_result.py:103: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_impl = <HookImpl plugin_name='C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py', plugin=<module 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>\nhook_name = 'pytest_runtest_call', args = [<Function test_help_about_details_flow>]\n\n    def run_old_style_hookwrapper(\n        hook_impl: HookImpl, hook_name: str, args: Sequence[object]\n    ) -> Teardown:\n        \"\"\"\n        backward compatibility wrapper to run a old style hookwrapper as a wrapper\n        \"\"\"\n    \n        teardown: Teardown = cast(Teardown, hook_impl.function(*args))\n        try:\n            next(teardown)\n        except StopIteration:\n            _raise_wrapfail(teardown, \"did not yield\")\n        try:\n>           res = yield\n                  ^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\\\Users\\\\saraswat.gagan\\\\Ap...ule 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>, ...]\ncaller_kwargs = {'item': <Function test_help_about_details_flow>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            if firstresult:  # first result hooks return a single value\n                result = results[0] if results else None\n            else:\n                result = results\n    \n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                try:\n                    if exception is not None:\n                        try:\n>                           teardown.throw(exception)\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:139: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <CaptureManager _method='no' _global_capturing=<MultiCapture out=None err=None in_=None _state='suspended' _in_suspended=False> _capture_fixture=None>\nitem = <Function test_help_about_details_flow>\n\n    @hookimpl(wrapper=True)\n    def pytest_runtest_call(self, item: Item) -> Generator[None]:\n        with self.item_capture(\"call\", item):\n>           return (yield)\n                    ^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\_pytest\\capture.py:900: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\\\Users\\\\saraswat.gagan\\\\Ap...ule 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>, ...]\ncaller_kwargs = {'item': <Function test_help_about_details_flow>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            if firstresult:  # first result hooks return a single value\n                result = results[0] if results else None\n            else:\n                result = results\n    \n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                try:\n                    if exception is not None:\n                        try:\n>                           teardown.throw(exception)\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:139: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nitem = <Function test_help_about_details_flow>\n\n    @hookimpl(wrapper=True)\n    def pytest_runtest_call(item: Item) -> Generator[None]:\n        xfailed = item.stash.get(xfailed_key, None)\n        if xfailed is None:\n            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n    \n        if xfailed and not item.config.option.runxfail and not xfailed.run:\n            xfail(\"[NOTRUN] \" + xfailed.reason)\n    \n        try:\n>           return (yield)\n                    ^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\_pytest\\skipping.py:268: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\\\Users\\\\saraswat.gagan\\\\Ap...ule 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>, ...]\ncaller_kwargs = {'item': <Function test_help_about_details_flow>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n>                       res = hook_impl.function(*args)\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:121: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nitem = <Function test_help_about_details_flow>\n\n    def pytest_runtest_call(item: Item) -> None:\n        _update_current_test_var(item, \"call\")\n        try:\n            del sys.last_type\n            del sys.last_value\n            del sys.last_traceback\n            if sys.version_info >= (3, 12, 0):\n                del sys.last_exc  # type:ignore[attr-defined]\n        except AttributeError:\n            pass\n        try:\n>           item.runtest()\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\_pytest\\runner.py:179: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Function test_help_about_details_flow>\n\n    def runtest(self) -> None:\n        \"\"\"Execute the underlying test function.\"\"\"\n>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\_pytest\\python.py:1720: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HookCaller 'pytest_pyfunc_call'>, kwargs = {'pyfuncitem': <Function test_help_about_details_flow>}, firstresult = True\n\n    def __call__(self, **kwargs: object) -> Any:\n        \"\"\"Call the hook.\n    \n        Only accepts keyword arguments, which should match the hook\n        specification.\n    \n        Returns the result(s) of calling all registered plugins, see\n        :ref:`calling`.\n        \"\"\"\n        assert not self.is_historic(), (\n            \"Cannot directly call a historic hook - use call_historic instead.\"\n        )\n        self._verify_all_args_are_provided(kwargs)\n        firstresult = self.spec.opts.get(\"firstresult\", False) if self.spec else False\n        # Copy because plugins may register other plugins during iteration (#438).\n>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_hooks.py:512: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_pytest.config.PytestPluginManager object at 0x000002A747C16F90>, hook_name = 'pytest_pyfunc_call'\nmethods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\\\Users\\\\saraswat.gagan\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python313\\\\Lib\\\\site-packages\\\\_pytest\\\\python.py'>>]\nkwargs = {'pyfuncitem': <Function test_help_about_details_flow>}, firstresult = True\n\n    def _hookexec(\n        self,\n        hook_name: str,\n        methods: Sequence[HookImpl],\n        kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        # called from all hookcaller instances.\n        # enable_tracing will set its own wrapping function at self._inner_hookexec\n>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_manager.py:120: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_pyfunc_call'\nhook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\\\Users\\\\saraswat.gagan\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python313\\\\Lib\\\\site-packages\\\\_pytest\\\\python.py'>>]\ncaller_kwargs = {'pyfuncitem': <Function test_help_about_details_flow>}, firstresult = True\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            if firstresult:  # first result hooks return a single value\n                result = results[0] if results else None\n            else:\n                result = results\n    \n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                try:\n                    if exception is not None:\n                        try:\n                            teardown.throw(exception)\n                        except RuntimeError as re:\n                            # StopIteration from generator causes RuntimeError\n                            # even for coroutine usage - see #544\n                            if (\n                                isinstance(exception, StopIteration)\n                                and re.__cause__ is exception\n                            ):\n                                teardown.close()\n                                continue\n                            else:\n                                raise\n                    else:\n                        teardown.send(result)\n                    # Following is unreachable for a well behaved hook wrapper.\n                    # Try to force finalizers otherwise postponed till GC action.\n                    # Note: close() may raise if generator handles GeneratorExit.\n                    teardown.close()\n                except StopIteration as si:\n                    result = si.value\n                    exception = None\n                    continue\n                except BaseException as e:\n                    exception = e\n                    continue\n                _raise_wrapfail(teardown, \"has second yield\")\n    \n        if exception is not None:\n>           raise exception\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:167: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_pyfunc_call'\nhook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\\\Users\\\\saraswat.gagan\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python313\\\\Lib\\\\site-packages\\\\_pytest\\\\python.py'>>]\ncaller_kwargs = {'pyfuncitem': <Function test_help_about_details_flow>}, firstresult = True\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n>                       res = hook_impl.function(*args)\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:121: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npyfuncitem = <Function test_help_about_details_flow>\n\n    @hookimpl(trylast=True)\n    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:\n        testfunction = pyfuncitem.obj\n        if is_async_function(testfunction):\n            async_fail(pyfuncitem.nodeid)\n        funcargs = pyfuncitem.funcargs\n        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n>       result = testfunction(**testargs)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\_pytest\\python.py:166: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\napp = <pywinauto.application.Application object at 0x000002A74BAB2850>\n\n>   ???\n\nC:\\5SQAMA\\MobileApps-qama_regression_ascendion_dry_run_ready_v2\\tests\\windows\\wja\\test_wja2_help_about.py:13: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <libs.flows.windows.wja.wja_main_page.WJAMainPage object at 0x000002A74CE01BD0>\n\n    def open_about_details_and_close(self):\n>       self.open_about()\n\nlibs\\flows\\windows\\wja\\wja_main_page.py:30: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <libs.flows.windows.wja.wja_main_page.WJAMainPage object at 0x000002A74CE01BD0>\n\n    def open_about(self):\n>       self.focus_window()\n\nlibs\\flows\\windows\\wja\\wja_main_page.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <libs.flows.windows.wja.wja_main_page.WJAMainPage object at 0x000002A74CE01BD0>\n\n    def focus_window(self):\n>       self.main_window.set_focus()\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nlibs\\flows\\windows\\wja\\base_page.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pywinauto.application.WindowSpecification object at 0x000002A74CE16AC0>, attr_name = 'set_focus'\n\n    def __getattribute__(self, attr_name):\n        \"\"\"\n        Attribute access for this class\n    \n        If we already have criteria for both dialog and control then\n        resolve the control and return the requested attribute.\n    \n        If we have only criteria for the dialog but the attribute\n        requested is an attribute of DialogWrapper then resolve the\n        dialog and return the requested attribute.\n    \n        Otherwise delegate functionality to :func:`__getitem__` - which\n        sets the appropriate criteria for the control.\n        \"\"\"\n        allow_magic_lookup = object.__getattribute__(self, \"allow_magic_lookup\")  # Beware of recursions here!\n        if not allow_magic_lookup:\n            try:\n                return object.__getattribute__(self, attr_name)\n            except AttributeError:\n                wrapper_object = self.wrapper_object()\n                try:\n                    return getattr(wrapper_object, attr_name)\n                except AttributeError:\n                    message = (\n                        'Attribute \"%s\" exists neither on %s object nor on'\n                        'targeted %s element wrapper (typo? or set allow_magic_lookup to True?)' %\n                        (attr_name, self.__class__, wrapper_object.__class__))\n                    raise AttributeError(message)\n    \n        if attr_name in ['__dict__', '__members__', '__methods__', '__class__', '__name__']:\n            return object.__getattribute__(self, attr_name)\n    \n        if attr_name in dir(self.__class__):\n            return object.__getattribute__(self, attr_name)\n    \n        if attr_name in self.__dict__:\n            return self.__dict__[attr_name]\n    \n        # if we already have 2 levels of criteria (dlg, control)\n        # this third must be an attribute so resolve and get the\n        # attribute and return it\n        if len(self.criteria) >= 2:  # FIXME - this is surprising\n    \n            ctrls = self.__resolve_control(self.criteria)\n    \n            try:\n                return getattr(ctrls[-1], attr_name)\n            except AttributeError:\n                return self.child_window(best_match=attr_name)\n        else:\n            # FIXME - I don't get this part at all, why is it win32-specific and why not keep the same logic as above?\n            # if we have been asked for an attribute of the dialog\n            # then resolve the window and return the attribute\n            desktop_wrapper = self.backend.generic_wrapper_class(self.backend.element_info_class())\n            need_to_resolve = (len(self.criteria) == 1 and hasattr(desktop_wrapper, attr_name))\n            if hasattr(self.backend, 'dialog_class'):\n                need_to_resolve = need_to_resolve and hasattr(self.backend.dialog_class, attr_name)\n            # Probably there is no DialogWrapper for another backend\n    \n            if need_to_resolve:\n>               ctrls = self.__resolve_control(self.criteria)\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pywinauto\\application.py:396: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pywinauto.application.WindowSpecification object at 0x000002A74CE16AC0>\ncriteria = [{'app': <pywinauto.application.Application object at 0x000002A74BAB2850>, 'backend': 'uia', 'title_re': '.*HP Web Jetadmin.*'}], timeout = 5.0\nretry_interval = 0.09\n\n    def __resolve_control(self, criteria, timeout=None, retry_interval=None):\n        \"\"\"\n        Find a control using criteria\n    \n        * **criteria** - a list that contains 1 or 2 dictionaries\n    \n             1st element is search criteria for the dialog\n    \n             2nd element is search criteria for a control of the dialog\n    \n        * **timeout** -  maximum length of time to try to find the controls (default 5)\n        * **retry_interval** - how long to wait between each retry (default .2)\n        \"\"\"\n        if timeout is None:\n            timeout = Timings.window_find_timeout\n        if retry_interval is None:\n            retry_interval = Timings.window_find_retry\n    \n        try:\n            ctrl = wait_until_passes(\n                timeout,\n                retry_interval,\n                self.__get_ctrl,\n                (findwindows.ElementNotFoundError,\n                 findbestmatch.MatchError,\n                 controls.InvalidWindowHandle,\n                 controls.InvalidElement),\n                criteria)\n    \n        except TimeoutError as e:\n>           raise e.original_exception\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pywinauto\\application.py:261: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntimeout = 5.0, retry_interval = 0.09\nfunc = <bound method WindowSpecification.__get_ctrl of <pywinauto.application.WindowSpecification object at 0x000002A74CE16AC0>>\nexceptions = (<class 'pywinauto.findwindows.ElementNotFoundError'>, <class 'pywinauto.findbestmatch.MatchError'>, <class 'pywinauto.controls.hwndwrapper.InvalidWindowHandle'>, <class 'pywinauto.base_wrapper.InvalidElement'>)\nargs = ([{'app': <pywinauto.application.Application object at 0x000002A74BAB2850>, 'backend': 'uia', 'title_re': '.*HP Web Jetadmin.*'}],), kwargs = {}\nstart = 5846.0942149, time_left = -2.343674199999441, err = TimeoutError()\n\n    def wait_until_passes(timeout,\n                          retry_interval,\n                          func,\n                          exceptions=(Exception),\n                          *args, **kwargs):\n        \"\"\"\n        Wait until ``func(*args, **kwargs)`` does not raise one of the exceptions\n    \n        * **timeout**  how long the function will try the function\n        * **retry_interval**  how long to wait between retries\n        * **func** the function that will be executed\n        * **exceptions**  list of exceptions to test against (default: Exception)\n        * **args** optional arguments to be passed to func when called\n        * **kwargs** optional keyword arguments to be passed to func when called\n    \n        Returns the return value of the function\n        If the operation times out then the original exception raised is in\n        the 'original_exception' attribute of the raised exception.\n    \n        e.g. ::\n    \n            try:\n                # wait a maximum of 10.5 seconds for the\n                # window to be found in increments of .5 of a second.\n                # P.int a message and re-raise the original exception if never found.\n                wait_until_passes(10.5, .5, self.Exists, (ElementNotFoundError))\n            except TimeoutError as e:\n                print(\"timed out\")\n                raise e.\n        \"\"\"\n        start = timestamp()\n    \n        # keep trying until the timeout is passed\n        while True:\n            try:\n                # Call the function with any arguments\n>               func_val = func(*args, **kwargs)\n                           ^^^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pywinauto\\timings.py:436: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pywinauto.application.WindowSpecification object at 0x000002A74CE16AC0>\ncriteria_ = [{'app': <pywinauto.application.Application object at 0x000002A74BAB2850>, 'backend': 'uia', 'title_re': '.*HP Web Jetadmin.*'}]\n\n    def __get_ctrl(self, criteria_):\n        \"\"\"Get a control based on the various criteria\"\"\"\n        # make a copy of the criteria\n        criteria = [crit.copy() for crit in criteria_]\n        # find the dialog\n        if 'backend' not in criteria[0]:\n            criteria[0]['backend'] = self.backend.name\n        if self.app is not None:\n            # find_elements(...) accepts only \"process\" argument\n            criteria[0]['process'] = self.app.process\n            del criteria[0]['app']\n>       dialog = self.backend.generic_wrapper_class(findwindows.find_element(**criteria[0]))\n                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pywinauto\\application.py:203: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nkwargs = {'backend': 'uia', 'process': 14324, 'title_re': '.*HP Web Jetadmin.*'}, elements = []\n\n    def find_element(**kwargs):\n        \"\"\"\n        Call find_elements and ensure that only one element is returned\n    \n        Calls find_elements with exactly the same arguments as it is called with\n        so please see :py:func:`find_elements` for the full parameters description.\n        \"\"\"\n        elements = find_elements(**kwargs)\n    \n        if not elements:\n>           raise ElementNotFoundError(kwargs)\nE           pywinauto.findwindows.ElementNotFoundError: {'title_re': '.*HP Web Jetadmin.*', 'backend': 'uia', 'process': 14324}\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pywinauto\\findwindows.py:87: ElementNotFoundError"}, "attachments": [{"name": "Test Duration", "source": "4f81c736-5f6f-4a53-b4f7-e07a391cba87-attachment.txt", "type": "text/plain"}, {"name": "Failure Screenshot", "source": "a29d2375-318e-4ba3-9f25-a03936f7acab-attachment.png", "type": "image/png"}, {"name": "Execution Log", "source": "e583270c-31f4-48a0-ae38-ab2d5865009c-attachment.txt", "type": "text/plain"}], "start": 1767636461233, "stop": 1767636468583, "uuid": "4f2bd342-d2fc-40a2-85b7-85f0be8f3172", "historyId": "915276b91ba1df0b8227e526009ce991", "testCaseId": "915276b91ba1df0b8227e526009ce991", "fullName": "windows.wja.test_wja2_help_about#test_help_about_details_flow", "labels": [{"name": "parentSuite", "value": "windows.wja"}, {"name": "suite", "value": "test_wja2_help_about"}, {"name": "host", "value": "ASCINLAP61483"}, {"name": "thread", "value": "14224-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "windows.wja.test_wja2_help_about"}], "titlePath": ["windows", "wja", "test_wja2_help_about.py"]}