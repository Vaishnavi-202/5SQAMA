{"name": "test_device_navigation_tree_items", "status": "broken", "statusDetails": {"message": "_ctypes.COMError: (-2147220992, None, (None, None, None, 0, None))", "trace": "cls = <class '_pytest.runner.CallInfo'>, func = <function call_and_report.<locals>.<lambda> at 0x000002A74E089800>, when = 'call'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: Callable[[], TResult],\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,\n    ) -> CallInfo[TResult]:\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :type func: Callable[[], _pytest.runner.TResult]\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        instant = timing.Instant()\n        try:\n>           result: TResult | None = func()\n                                     ^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\_pytest\\runner.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>       lambda: runtest_hook(item=item, **kwds),\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        when=when,\n        reraise=get_reraise_exceptions(item.config),\n    )\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\_pytest\\runner.py:245: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HookCaller 'pytest_runtest_call'>, kwargs = {'item': <Function test_device_navigation_tree_items>}, firstresult = False\n\n    def __call__(self, **kwargs: object) -> Any:\n        \"\"\"Call the hook.\n    \n        Only accepts keyword arguments, which should match the hook\n        specification.\n    \n        Returns the result(s) of calling all registered plugins, see\n        :ref:`calling`.\n        \"\"\"\n        assert not self.is_historic(), (\n            \"Cannot directly call a historic hook - use call_historic instead.\"\n        )\n        self._verify_all_args_are_provided(kwargs)\n        firstresult = self.spec.opts.get(\"firstresult\", False) if self.spec else False\n        # Copy because plugins may register other plugins during iteration (#438).\n>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_hooks.py:512: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_pytest.config.PytestPluginManager object at 0x000002A747C16F90>, hook_name = 'pytest_runtest_call'\nmethods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\\\Users\\\\saraswat.gagan\\\\Ap...ule 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>, ...]\nkwargs = {'item': <Function test_device_navigation_tree_items>}, firstresult = False\n\n    def _hookexec(\n        self,\n        hook_name: str,\n        methods: Sequence[HookImpl],\n        kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        # called from all hookcaller instances.\n        # enable_tracing will set its own wrapping function at self._inner_hookexec\n>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_manager.py:120: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\\\Users\\\\saraswat.gagan\\\\Ap...ule 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>, ...]\ncaller_kwargs = {'item': <Function test_device_navigation_tree_items>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            if firstresult:  # first result hooks return a single value\n                result = results[0] if results else None\n            else:\n                result = results\n    \n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                try:\n                    if exception is not None:\n                        try:\n                            teardown.throw(exception)\n                        except RuntimeError as re:\n                            # StopIteration from generator causes RuntimeError\n                            # even for coroutine usage - see #544\n                            if (\n                                isinstance(exception, StopIteration)\n                                and re.__cause__ is exception\n                            ):\n                                teardown.close()\n                                continue\n                            else:\n                                raise\n                    else:\n                        teardown.send(result)\n                    # Following is unreachable for a well behaved hook wrapper.\n                    # Try to force finalizers otherwise postponed till GC action.\n                    # Note: close() may raise if generator handles GeneratorExit.\n                    teardown.close()\n                except StopIteration as si:\n                    result = si.value\n                    exception = None\n                    continue\n                except BaseException as e:\n                    exception = e\n                    continue\n                _raise_wrapfail(teardown, \"has second yield\")\n    \n        if exception is not None:\n>           raise exception\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:167: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\\\Users\\\\saraswat.gagan\\\\Ap...ule 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>, ...]\ncaller_kwargs = {'item': <Function test_device_navigation_tree_items>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            if firstresult:  # first result hooks return a single value\n                result = results[0] if results else None\n            else:\n                result = results\n    \n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                try:\n                    if exception is not None:\n                        try:\n>                           teardown.throw(exception)\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:139: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_pytest.logging.LoggingPlugin object at 0x000002A74CE041A0>, item = <Function test_device_navigation_tree_items>\n\n    @hookimpl(wrapper=True)\n    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:\n        self.log_cli_handler.set_when(\"call\")\n    \n        with self._runtest_for(item, \"call\"):\n>           yield\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\_pytest\\logging.py:850: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\\\Users\\\\saraswat.gagan\\\\Ap...ule 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>, ...]\ncaller_kwargs = {'item': <Function test_device_navigation_tree_items>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            if firstresult:  # first result hooks return a single value\n                result = results[0] if results else None\n            else:\n                result = results\n    \n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                try:\n                    if exception is not None:\n                        try:\n>                           teardown.throw(exception)\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:139: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_impl = <HookImpl plugin_name='allure_listener', plugin=<allure_pytest.listener.AllureListener object at 0x000002A74CBFAE40>>\nhook_name = 'pytest_runtest_call', args = [<Function test_device_navigation_tree_items>]\n\n    def run_old_style_hookwrapper(\n        hook_impl: HookImpl, hook_name: str, args: Sequence[object]\n    ) -> Teardown:\n        \"\"\"\n        backward compatibility wrapper to run a old style hookwrapper as a wrapper\n        \"\"\"\n    \n        teardown: Teardown = cast(Teardown, hook_impl.function(*args))\n        try:\n            next(teardown)\n        except StopIteration:\n            _raise_wrapfail(teardown, \"did not yield\")\n        try:\n            res = yield\n            result = Result(res, None)\n        except BaseException as exc:\n            result = Result(None, exc)\n        try:\n            teardown.send(result)\n        except StopIteration:\n            pass\n        except BaseException as e:\n            _warn_teardown_exception(hook_name, hook_impl, e)\n            raise\n        else:\n            _raise_wrapfail(teardown, \"has second yield\")\n        finally:\n            teardown.close()\n>       return result.get_result()\n               ^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:53: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pluggy._result.Result object at 0x000002A74E7DC400>\n\n    def get_result(self) -> ResultType:\n        \"\"\"Get the result(s) for this hook call.\n    \n        If the hook was marked as a ``firstresult`` only a single value\n        will be returned, otherwise a list of results.\n        \"\"\"\n        __tracebackhide__ = True\n        exc = self._exception\n        tb = self._traceback\n        if exc is None:\n            return cast(ResultType, self._result)\n        else:\n>           raise exc.with_traceback(tb)\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_result.py:103: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_impl = <HookImpl plugin_name='allure_listener', plugin=<allure_pytest.listener.AllureListener object at 0x000002A74CBFAE40>>\nhook_name = 'pytest_runtest_call', args = [<Function test_device_navigation_tree_items>]\n\n    def run_old_style_hookwrapper(\n        hook_impl: HookImpl, hook_name: str, args: Sequence[object]\n    ) -> Teardown:\n        \"\"\"\n        backward compatibility wrapper to run a old style hookwrapper as a wrapper\n        \"\"\"\n    \n        teardown: Teardown = cast(Teardown, hook_impl.function(*args))\n        try:\n            next(teardown)\n        except StopIteration:\n            _raise_wrapfail(teardown, \"did not yield\")\n        try:\n>           res = yield\n                  ^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\\\Users\\\\saraswat.gagan\\\\Ap...ule 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>, ...]\ncaller_kwargs = {'item': <Function test_device_navigation_tree_items>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            if firstresult:  # first result hooks return a single value\n                result = results[0] if results else None\n            else:\n                result = results\n    \n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                try:\n                    if exception is not None:\n                        try:\n>                           teardown.throw(exception)\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:139: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_impl = <HookImpl plugin_name='C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py', plugin=<module 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>\nhook_name = 'pytest_runtest_call', args = [<Function test_device_navigation_tree_items>]\n\n    def run_old_style_hookwrapper(\n        hook_impl: HookImpl, hook_name: str, args: Sequence[object]\n    ) -> Teardown:\n        \"\"\"\n        backward compatibility wrapper to run a old style hookwrapper as a wrapper\n        \"\"\"\n    \n        teardown: Teardown = cast(Teardown, hook_impl.function(*args))\n        try:\n            next(teardown)\n        except StopIteration:\n            _raise_wrapfail(teardown, \"did not yield\")\n        try:\n            res = yield\n            result = Result(res, None)\n        except BaseException as exc:\n            result = Result(None, exc)\n        try:\n            teardown.send(result)\n        except StopIteration:\n            pass\n        except BaseException as e:\n            _warn_teardown_exception(hook_name, hook_impl, e)\n            raise\n        else:\n            _raise_wrapfail(teardown, \"has second yield\")\n        finally:\n            teardown.close()\n>       return result.get_result()\n               ^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:53: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pluggy._result.Result object at 0x000002A74E7DCAC0>\n\n    def get_result(self) -> ResultType:\n        \"\"\"Get the result(s) for this hook call.\n    \n        If the hook was marked as a ``firstresult`` only a single value\n        will be returned, otherwise a list of results.\n        \"\"\"\n        __tracebackhide__ = True\n        exc = self._exception\n        tb = self._traceback\n        if exc is None:\n            return cast(ResultType, self._result)\n        else:\n>           raise exc.with_traceback(tb)\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_result.py:103: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_impl = <HookImpl plugin_name='C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py', plugin=<module 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>\nhook_name = 'pytest_runtest_call', args = [<Function test_device_navigation_tree_items>]\n\n    def run_old_style_hookwrapper(\n        hook_impl: HookImpl, hook_name: str, args: Sequence[object]\n    ) -> Teardown:\n        \"\"\"\n        backward compatibility wrapper to run a old style hookwrapper as a wrapper\n        \"\"\"\n    \n        teardown: Teardown = cast(Teardown, hook_impl.function(*args))\n        try:\n            next(teardown)\n        except StopIteration:\n            _raise_wrapfail(teardown, \"did not yield\")\n        try:\n>           res = yield\n                  ^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\\\Users\\\\saraswat.gagan\\\\Ap...ule 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>, ...]\ncaller_kwargs = {'item': <Function test_device_navigation_tree_items>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            if firstresult:  # first result hooks return a single value\n                result = results[0] if results else None\n            else:\n                result = results\n    \n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                try:\n                    if exception is not None:\n                        try:\n>                           teardown.throw(exception)\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:139: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <CaptureManager _method='no' _global_capturing=<MultiCapture out=None err=None in_=None _state='suspended' _in_suspended=False> _capture_fixture=None>\nitem = <Function test_device_navigation_tree_items>\n\n    @hookimpl(wrapper=True)\n    def pytest_runtest_call(self, item: Item) -> Generator[None]:\n        with self.item_capture(\"call\", item):\n>           return (yield)\n                    ^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\_pytest\\capture.py:900: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\\\Users\\\\saraswat.gagan\\\\Ap...ule 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>, ...]\ncaller_kwargs = {'item': <Function test_device_navigation_tree_items>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            if firstresult:  # first result hooks return a single value\n                result = results[0] if results else None\n            else:\n                result = results\n    \n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                try:\n                    if exception is not None:\n                        try:\n>                           teardown.throw(exception)\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:139: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nitem = <Function test_device_navigation_tree_items>\n\n    @hookimpl(wrapper=True)\n    def pytest_runtest_call(item: Item) -> Generator[None]:\n        xfailed = item.stash.get(xfailed_key, None)\n        if xfailed is None:\n            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n    \n        if xfailed and not item.config.option.runxfail and not xfailed.run:\n            xfail(\"[NOTRUN] \" + xfailed.reason)\n    \n        try:\n>           return (yield)\n                    ^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\_pytest\\skipping.py:268: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\\\Users\\\\saraswat.gagan\\\\Ap...ule 'qama_regression_ascendion.tests.conftest' from 'C:\\\\5SQAMA\\\\qama_regression_ascendion\\\\tests\\\\conftest.py'>>, ...]\ncaller_kwargs = {'item': <Function test_device_navigation_tree_items>}, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n>                       res = hook_impl.function(*args)\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:121: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nitem = <Function test_device_navigation_tree_items>\n\n    def pytest_runtest_call(item: Item) -> None:\n        _update_current_test_var(item, \"call\")\n        try:\n            del sys.last_type\n            del sys.last_value\n            del sys.last_traceback\n            if sys.version_info >= (3, 12, 0):\n                del sys.last_exc  # type:ignore[attr-defined]\n        except AttributeError:\n            pass\n        try:\n>           item.runtest()\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\_pytest\\runner.py:179: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Function test_device_navigation_tree_items>\n\n    def runtest(self) -> None:\n        \"\"\"Execute the underlying test function.\"\"\"\n>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\_pytest\\python.py:1720: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HookCaller 'pytest_pyfunc_call'>, kwargs = {'pyfuncitem': <Function test_device_navigation_tree_items>}, firstresult = True\n\n    def __call__(self, **kwargs: object) -> Any:\n        \"\"\"Call the hook.\n    \n        Only accepts keyword arguments, which should match the hook\n        specification.\n    \n        Returns the result(s) of calling all registered plugins, see\n        :ref:`calling`.\n        \"\"\"\n        assert not self.is_historic(), (\n            \"Cannot directly call a historic hook - use call_historic instead.\"\n        )\n        self._verify_all_args_are_provided(kwargs)\n        firstresult = self.spec.opts.get(\"firstresult\", False) if self.spec else False\n        # Copy because plugins may register other plugins during iteration (#438).\n>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_hooks.py:512: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_pytest.config.PytestPluginManager object at 0x000002A747C16F90>, hook_name = 'pytest_pyfunc_call'\nmethods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\\\Users\\\\saraswat.gagan\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python313\\\\Lib\\\\site-packages\\\\_pytest\\\\python.py'>>]\nkwargs = {'pyfuncitem': <Function test_device_navigation_tree_items>}, firstresult = True\n\n    def _hookexec(\n        self,\n        hook_name: str,\n        methods: Sequence[HookImpl],\n        kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        # called from all hookcaller instances.\n        # enable_tracing will set its own wrapping function at self._inner_hookexec\n>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_manager.py:120: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_pyfunc_call'\nhook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\\\Users\\\\saraswat.gagan\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python313\\\\Lib\\\\site-packages\\\\_pytest\\\\python.py'>>]\ncaller_kwargs = {'pyfuncitem': <Function test_device_navigation_tree_items>}, firstresult = True\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            if firstresult:  # first result hooks return a single value\n                result = results[0] if results else None\n            else:\n                result = results\n    \n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                try:\n                    if exception is not None:\n                        try:\n                            teardown.throw(exception)\n                        except RuntimeError as re:\n                            # StopIteration from generator causes RuntimeError\n                            # even for coroutine usage - see #544\n                            if (\n                                isinstance(exception, StopIteration)\n                                and re.__cause__ is exception\n                            ):\n                                teardown.close()\n                                continue\n                            else:\n                                raise\n                    else:\n                        teardown.send(result)\n                    # Following is unreachable for a well behaved hook wrapper.\n                    # Try to force finalizers otherwise postponed till GC action.\n                    # Note: close() may raise if generator handles GeneratorExit.\n                    teardown.close()\n                except StopIteration as si:\n                    result = si.value\n                    exception = None\n                    continue\n                except BaseException as e:\n                    exception = e\n                    continue\n                _raise_wrapfail(teardown, \"has second yield\")\n    \n        if exception is not None:\n>           raise exception\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:167: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_pyfunc_call'\nhook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\\\Users\\\\saraswat.gagan\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python313\\\\Lib\\\\site-packages\\\\_pytest\\\\python.py'>>]\ncaller_kwargs = {'pyfuncitem': <Function test_device_navigation_tree_items>}, firstresult = True\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError as e:\n                        # coverage bug - this is tested\n                        for argname in hook_impl.argnames:  # pragma: no cover\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                ) from e\n    \n                    if hook_impl.hookwrapper:\n                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)\n    \n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n    \n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n>                       res = hook_impl.function(*args)\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pluggy\\_callers.py:121: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npyfuncitem = <Function test_device_navigation_tree_items>\n\n    @hookimpl(trylast=True)\n    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:\n        testfunction = pyfuncitem.obj\n        if is_async_function(testfunction):\n            async_fail(pyfuncitem.nodeid)\n        funcargs = pyfuncitem.funcargs\n        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n>       result = testfunction(**testargs)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\_pytest\\python.py:166: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\napp = <pywinauto.application.Application object at 0x000002A74BAB2850>\n\n>   ???\n\nC:\\5SQAMA\\MobileApps-qama_regression_ascendion_dry_run_ready_v2\\tests\\windows\\wja\\test_wja3_tree_navigate.py:9: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <libs.flows.windows.wja.wja_device_tree_page.WJADeviceTreePage object at 0x000002A74CE06CF0>\n\n    def click_all_devices(self):\n>       self._select(\"all\")\n\nlibs\\flows\\windows\\wja\\wja_device_tree_page.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <libs.flows.windows.wja.wja_device_tree_page.WJADeviceTreePage object at 0x000002A74CE06CF0>, key = 'all'\n\n    def _select(self, key):\n        with allure.step(f\"Select device tree item: {key}\"):\n            if key not in self._items:\n                log.info(f\"Caching tree item: {TREE_PATHS[key]}\")\n                self._items[key] = self._tree.get_item(TREE_PATHS[key])\n    \n            log.info(f\"Selecting tree item: {key}\")\n>           self._items[key].select()\n\nlibs\\flows\\windows\\wja\\wja_device_tree_page.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <uia_controls.TreeItemWrapper - 'All Devices (0)', TreeItem, 5740354900026072187>\n\n    def select(self):\n        \"\"\"Select the item\n    \n        Only items supporting SelectionItem pattern should answer.\n        Raise NoPatternInterfaceError if the pattern is not supported\n    \n        Usually applied for controls like: a radio button, a tree view item\n        or a list item.\n        \"\"\"\n>       self.iface_selection_item.Select()\nE       _ctypes.COMError: (-2147220992, None, (None, None, None, 0, None))\n\nC:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pywinauto\\controls\\uiawrapper.py:605: COMError"}, "steps": [{"name": "Select device tree item: all", "status": "broken", "statusDetails": {"message": "_ctypes.COMError: (-2147220992, None, (None, None, None, 0, None))\n", "trace": "  File \"C:\\5SQAMA\\qama_regression_ascendion\\libs\\flows\\windows\\wja\\wja_device_tree_page.py\", line 41, in _select\n    self._items[key].select()\n    ~~~~~~~~~~~~~~~~~~~~~~~^^\n  File \"C:\\Users\\saraswat.gagan\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\pywinauto\\controls\\uiawrapper.py\", line 605, in select\n    self.iface_selection_item.Select()\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^\n"}, "start": 1767636494653, "stop": 1767636500658}], "attachments": [{"name": "Test Duration", "source": "12628284-5310-4472-a05e-3e3285a8a5e6-attachment.txt", "type": "text/plain"}, {"name": "Failure Screenshot", "source": "bf02e792-c92f-4263-855c-4358fbba36a6-attachment.png", "type": "image/png"}, {"name": "Execution Log", "source": "2a848d53-4aad-4054-a928-51625c95ce90-attachment.txt", "type": "text/plain"}, {"name": "log", "source": "51440691-f4de-4a4c-9f98-8a71a7eeaf5c-attachment.txt", "type": "text/plain"}], "start": 1767636471071, "stop": 1767636500678, "uuid": "cdd2f5c1-3b56-4ca1-88ef-9f358458e57d", "historyId": "35f6c5b2fcf8899acea42b6843822ba5", "testCaseId": "35f6c5b2fcf8899acea42b6843822ba5", "fullName": "windows.wja.test_wja3_tree_navigate#test_device_navigation_tree_items", "labels": [{"name": "parentSuite", "value": "windows.wja"}, {"name": "suite", "value": "test_wja3_tree_navigate"}, {"name": "host", "value": "ASCINLAP61483"}, {"name": "thread", "value": "14224-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "windows.wja.test_wja3_tree_navigate"}], "titlePath": ["windows", "wja", "test_wja3_tree_navigate.py"]}